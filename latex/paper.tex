\documentclass[conference]{IEEEtran}  % Formato tipo IEEE para conferencias

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{cite}       % Para referencias IEEE
\usepackage{graphicx}   % Para incluir imágenes
\usepackage{amsmath}    % Para ecuaciones
\usepackage{hyperref}   % Para enlaces
\usepackage{booktabs}

\renewcommand{\IEEEkeywordsname}{Palabras clave}

\title{Lógica Combinacional: Puerta con contraseña}

\author{
    \IEEEauthorblockA{Instituto Tecnológico de Costa Rica\\
    Escuela de Ingeniería en Computadores\\
    CE1107 — Fundamentos de Arquitectura de Computadores\\}
    \IEEEauthorblockN{\\Autores: \\ Jafet José Diaz Morales - 2023053249 \\ Esteban Campos Abarca - 2022207705}
}

\begin{document}

\maketitle

\begin{abstract}
En este trabajo se presenta un algoritmo desarrollado principalmente con lógica combinacional, complementado con algunos elementos secuenciales así como otros componentes (sensores, LEDs, transistores, circuitos integrados, Raspberry Pi Pico W, motor CD, etc.) para implementar una puerta de acceso con contraseña. 

El diseño integra un sensor digital para la captura de la contraseña de 8 bits, utilizando un registro de desplazamiento serie-paralelo para mostrarla gráficamente mediante un visualizador de LEDs. Además, emplea un circuito decodificador para descifrar la contraseña y luego con un BCD a display de siete segmentos indicar el resultado de la verificación. Además, se construyó una maqueta con un motor que ilustrara el funcionamiento del sistema, aunque el accionador del motor no alcanzó el desempeño esperado. 

La metodología aplicada incluyó la construcción de los circuitos lógicos en protoboard (principalmente con compuertas TTL) y la verificación del correcto funcionamiento de cada entrada y salida. 

Los resultados muestran que el sistema puede reconocer y mostrar correctamente la contraseña, demostrando la aplicabilidad de la lógica combinacional y secuencial en el desarrollo de sistemas de seguridad digital simples, y proporcionando una base para implementaciones más complejas en el futuro.
\end{abstract}


\begin{IEEEkeywords}
Lógica combinacional, lógica secuencial, puerta con contraseña, decodificador, circuitos integrados, sensor.
\end{IEEEkeywords}

\section{Introducción}
En la actualidad, los sistemas de seguridad constituyen un área de interés tanto educativo como práctico. Implementar un sistema de seguridad digital simple permite demostrar y poner en práctica los fundamentos de la lógica combinacional y secuencial, logrando fortalecer estos conceptos teóricos. 

Por otro lado, los sistemas de acceso con contraseña combinan entradas digitales en serie y paralelas, circuitos de control y dispositivos de visualización para garantizar la verificación de la información de manera eficiente.

Este trabajo aborda el diseño e implementación de una puerta de acceso con contraseña de 8 bits utilizando principalmente lógica combinacional, complementada con elementos secuenciales y otros componentes electrónicos, tales como sensores, LEDs, registros de desplazamiento, decodificadores, un display de siete segmentos, Raspberry Pi Pico W, entre otros. El sistema permite la captura de la contraseña mediante un sensor digital, su visualización en LEDs y la verificación mediante un display de siete segmentos.

La metodología aplicada incluye la construcción de los circuitos en protoboard (utilizando principalmente compuertas TTL) y la prueba del correcto funcionamiento de cada entrada y salida, así como la integración de una maqueta que simula el funcionamiento de la puerta mediante un motor. Aunque algunos elementos del accionador de la maqueta no alcanzaron el desempeño esperado, el sistema logra reconocer y mostrar correctamente la contraseña en los dispositivos de visualización, demostrando la aplicabilidad de la lógica digital en sistemas de seguridad básicos.

El documento se organiza de la siguiente manera: la Sección II describe el algoritmo desarrollado, la Sección III presenta los resultados obtenidos, la Sección IV discute las conclusiones y la Sección V proporciona recomendaciones para implementaciones futuras.

\section{Algoritmo Desarrollado}
El algoritmo y solución en general para desarrollar el sistema se basa en la Figura \ref{fig:bloques}, que es un diagrama de bloques entregado por el profesor que muestra el flujo general del sistema de puerta con contraseña.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.35\textwidth]{images/Bloques.png}
    \caption{Diagrama de bloques del sistema de puerta con contraseña}
    \label{fig:bloques}
\end{figure}

De esta forma, se puede diseñar el circuito en base a cada uno de los submódulos. A continuación se desarrolla cada submódulo:

\subsection{Sensores}

Para este submódulo se utilizó el sensor de vibración con salida digital SW-420. Como la contraseña a mostrar es de 8 bits, el sensor captura 8 bits en serie usando la Raspberry Pi Pico W como debouncer, de forma tal que la raspberry tomara únicamente el primer 1 digital que el sensor detectara. La conexión de este sensor con la raspberry se muestra en la figura \ref{fig:esq}.

\subsection{Visualizador con LEDs}

Los 8 bits en serie se muestan con un LED y además se muestran paralelamente (con 8 LEDS). Para pasar la contraseña a paralelo se requiere de el registro de desplazamiento serie-paralelo.  

El registro realiza la conversión de 8 bits seriales a 8 bits en paralelo que son mostrados cada uno con un LED, de forma que el visualizador es meramente para ver el proceso que realiza el registro de desplazamiento y por esa razón el visualizador con LEDs viene después del registro. Esta conexión puede verse en la figura \ref{fig:esq}

\subsubsection{Registro de desplazamiento serie-paralelo}

Para pasar 8 bits serie a paralelo la señal serial del sensor, una señal de pulso de reloj y una señal de strobe/latch (desde la Raspberry) al registro de desplazamiento CD4094, de forma similar a lo hecho por \cite{micropython2025registro}. El CD4094, que es CMOS, se eligió por dos razones. 

\begin{enumerate}
    \item Los pines de la raspberry soportan 3.3 V. Al utilizar la raspberry como debouncer del sensor se tiene que utilizar 3.3 V para el sensor, de forma tal que su salida digital es también de 3.3 V. Por lo tanto, los 8 bits seriales son de 3.3 V
    \item No se consiguió comprar un registro de desplazamiento serie-paralelo que fuera TTL y que tuviera un latch (para poder guardar y fijar los datos)
    \item El registro debe guardar los datos por un tiempo, por lo que el latch es útil y necesario.
\end{enumerate}

Debido a esto, la salida en paralelo es inicialmente a 3.3 V. Esta salida es generalmente aceptable para la entrada de una compuerta TTL. Por ejemplo, en las 74LSxx suele ser:

\[
V_{IH} \geq 2.0 \,\text{V} \quad \Rightarrow \quad \text{``1 lógico''}
\]
\[
V_{IL} \leq 0.8 \,\text{V} \quad \Rightarrow \quad \text{``0 lógico''}
\]

Ahora bien, a pesar de que así serviría el circuito (por ser CMOS a TTL, si fuera al revés habrían problemas) para evitar errores en la lógica se utiliza un buffer 74LS241 con el fin de estabilizar la señal. El buffer al ser TTL va a recibir la señal del CMOS y va a estabilizarla a 5V, que es la norma en TTL. Esta conexión además requiere de resistencias $pull-down$ en las TTL de forma que si no se llega al VIH la salida sea establecida en 0 lógico. 

\subsection{Circuito Combinatorio (Circuitos Integrados)}

Esta sección consiste de dos decodificadores, uno para el estado de abierto y otro para el de cerrado. Los decodificadores se obtienen de la tabla de verdad \ref{tab:8in2out}. Note que solo hay una combinación que resulta en un 1 lógico para S1 y a su vez, solo hay una combinación (diferente a a de S1) para S2.

\begin{table}[h!]
\centering
\resizebox{\columnwidth}{!}{%
\begin{tabular}{cccccccc|cc} % <-- la barra | separa entradas y salidas
\toprule
\textbf{$A$} & \textbf{$B$} & \textbf{$C$} & \textbf{$D$} & 
\textbf{$E$} & \textbf{$F$} & \textbf{$G$} & \textbf{$H$} & 
\textbf{$S_1$} & \textbf{$S_2$} \\
\midrule
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\

\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\

1 & 1 & 0 & 0 & 0 & 1 & 1 & 0 & 1 & 0 \\

\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\

1 & 1 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 1 \\

\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\

1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 0 & 0 \\
\bottomrule
\end{tabular}%
}
\caption{Tabla de Verdad para decodificador de 8 bits a 2 salidas de 1 bit}
\label{tab:8in2out}
\end{table}

\subsubsection{Decodificador 8 Bits a 1 Bit para abierto (S1)}

Para realizar este decodificador, se toma el mintérmino para S1, así como se ve en la ecuación (1) :
\begin{equation}
S_1 = AB\overline{CDE}FG\overline{H}
\end{equation}

Note que al ser un solo mintérmino, la ecuación correspondiente a S1 está conformado por productos únicamente, las cuales se pueden representar como compuertas AND, tal y como se ve en la figura \ref{fig:s1y2}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{images/abrirYcerrar.png}
    \caption{Esquemático para decodificador de S1 y S2.}
    \label{fig:s1y2}
\end{figure}

Note que se utilizaron 4 compuertas AND de 3 entradas, esto debido a que se disponía de esas compuertas y porque permite "reutilizar" compuertas (la 1 y la 2, específicamente). 

\subsubsection{Decodificador 8 Bits a 1 Bit para cerrado (S2) } 

Para realizar este decodificador, se toma el mintérmino para S2, así como se ve en la ecuación (2) :
\begin{equation}
S_2 = AB\overline{C}DEFG\overline{H}
\end{equation}

Note que al ser un solo mintérmino, la ecuación correspondiente a S2 está conformado por productos únicamente, las cuales se pueden representar como compuertas AND, tal y como se ve en la figura \ref{fig:s1y2}

Note que también se utilizan 4 compuertas AND de 3 entradas, esto debido a que se disponía de esas compuertas. Sin embargo, note que las compuertas 1 y 2 son las mismas (1 tiene como entrada A,B y -C; 2 tiene como entradas G y -H), por lo tanto, se pueden reutilizar esas compuertas compuertas simplemente poniendo un cable exctra en la salida de las AND 1 y 2. 

Así, para realizar los dos decodificadores se utilizan 6 compuertas AND de 3 entradas, además de 4 compuertas NOT para las entradas que deben ir negadas.

\subsection{BCD a display de 7 segmentos utilizando un multiplexor}

Del circuito combinatorio se tienen dos bits S1 y S2 que representan dos posibles estados: abierto y cerrado, ambos indicados mediante un bit alto (1). La diferenciación entre estos dos estados puede hacerse de muchas maneras.

La seleccionada fue utilizando un multiplexor. El mux es un circuito combinatorio que escoge entre dos opciones dependiendo de la entrada selectora. El mux utilizado fue el SN74LS157 \cite{Sandorobotics_74LS157}.

Este mux tiene la capacidad de seleccionar justamente entre 2 entradas de 4 bits ($A_1,A_2,A_3,A_4$, lo mismo con B) según el bit selector SEL. Note además que se tiene un bit STR el cuál corresponde a la activación en bajo (o sea, si STR es 0, el Mux funciona normalmente, si STR es 1, el Mux muestra $0000$).

Así, con 2 bits se controlan 3 posibles combinaciones de 4 bits, con lo que intercambiando los pines de conexión del display de siete segmentos \cite{XLITX_5621BS} siguiendo el pinout de forma que una combinación que normalmente pondría un número ponga una letra (por ejemplo, si se intercambian los pines de G y D, es posible lograr que un 0000 (que normalmente muestra un 0 en el display) muestra una A, o si se cambia A y C, un 6 muestra una E).

Así, para mostrar 3 distintas letras se utiliza en el BCD:

\begin{itemize}
    \item $ A = 0000 $ (lo que sería un 0 normalmente)
    \item $ C = 1110 $ (lo que sería un 14 normalmente)
    \item $ E = 0110 $ (lo que sería un 6 normalmente)
\end{itemize}

Para combinaciones como la C fue necesario revisar el pinout y datasheet del BCD e identificar que combinación servía. Note en el datasheet \cite{TI_SN74LS47} que $1110$ activa la cantidad de LEDS necesarios, el resto es solo reacomodar los pines. 

De esta forma, teniendo las combinaciones que generan las letras deseadas, se puede usar el mux para mostrarlas.

\begin{itemize}
    \item Para mostrar A, se usa $S_1$ en STR, pues si en algún momento la clave de abierto se activa, mandará un 1, forzando un $0000$ en el mux y a su vez, mostrando la A.

    \item Para mostrar E y C, se usa $S_2$ en SEL, pues si en algún momento la clave de cerrado se activa, mandará un 1 lo que activará la segunda opción (4 bits fijos de antemano) y si no se pone la clave, se mantendrá un 0, poniendo la primera opción (4 bits fijos de antemano para poner la E).
    
\end{itemize}

Note que no hay conflictos, pues A y C no pueden existir a la vez (según la tabla de verdad). El único estado que falta por mostrar con display de 7 segmentos es el de lectura. Esto se realizó conectando el bit de latch (que viene de la raspberry pi pico w) al pin 2 (que corresponde al DP (el punto/dot) del display), de forma tal que cuando se está leyendo la contraseña, el punto se encienda. Esta conexión puede verse en el esquemático general mostrado más adelante en la figura \ref{fig:esq}. Note que el mux tiene entradas predefinidas A1...A4 y B1...B4, pues ya se sabe los bits correspondientes a las letras a mostrar.

\subsection{Circuito desacoplador y accionador}

El circuito desacoplador consiste en un puente H hecho con transistores 2N222 siguiendo el ejemplo de \cite{makordoba2025circuitoH}. El accionador consiste en un motor a la salida del puente H que mueve una puerta que sirve de maqueta. 

El puente H tiene 2 entradas que cambian la dirección del motor. Así, las entradas se conectan a S1 y S2, causando que si S1 = 1, el motor gira en una dirección y si S2 = 1, el motor gira en la dirección contraria. Observe en la tabla de verdad \ref{tab:8in2out} que S1 y S2 no pueden ser 1 a la vez, evitando así cualquier problema con el puente H.

De esta forma, el circuito para la puerta con contraseña está completo. A continuación se muestra un esquemático general del circuito \ref{fig:esq}. La parte superior representa el sensor, registro de desplazamiento, y visualizador LEDS. La parte de en medio es el circuito combinatorio con el decodificador, donde sus salidas S1 y S2 activan el puente H y el mux (que a su vez activa el BCD a display 7 segmentos)

\begin{figure}[h!] % h! = intenta colocar la figura exactamente aquí
    \centering    
    \includegraphics[width=0.35\textwidth]{images/esq.png} % Ajusta al 50% del ancho del texto
    \caption{Esquemático general del circuito completo: Sensor - Registro serie a paralelo - Visualizador LEDs - Circuito Combinatorio - BCD a 7 segmentos - Desacople y Accionador}
    \label{fig:esq}
\end{figure}

\section{Resultados}

En esta sección se presentan los resultados obtenidos tras la implementación del algoritmo realizado (puede verse el esquemático \ref{fig:esq}). Es importante aclarar que el circuito funcionó integrado, sin embargo, el puente H presentó imperfecciones y un comportamiento inesperado (una hipótesis es que el 0 lógico presentaba una corriente mínima, y eso creó algún cortocircuito o imperfección en el puente H), por lo que el motor y maqueta no funcionaban con regularidad. En la figura \ref{fig:motor} se muestra el circuito puente H con el motor:

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{images/motor.png}
    \caption{Puente H con motor}
    \label{fig:motor}
\end{figure}

Además, en la figura \ref{fig:luz}, muestra el estado de cerrado (en el visualizador LEDs, donde la LED azul más a la derecha es el bit más significativo) de forma exitosa:

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{images/luz.png}
    \caption{Visualizador LED para cerrado}
    \label{fig:luz}
\end{figure}

Por otro lado, en la figura \ref{fig:ejemplo}, muestra el estado de abierto display de 7 segmentos de forma exitosa:

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{images/ejemplo.png}
    \caption{Display de 7 segmentos para mostrar una A de abierto}
    \label{fig:ejemplo}
\end{figure}

Finalmente, se muestra el circuito completo en la figura \ref{fig:general}, donde se observa el caso de Error (previo) y actualmente leyendo del sensor. Es necesario aclarar que, al ser muchos casos, solo se muestran estas figuras, pues si se quisieran mostrar todos, tomaría mucho espacio. Así, se elige mostrar el resultado específico de motor, visualizador LEDs y display 7 segmentos, además de un resultado general.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.35\textwidth]{images/general.png}
    \caption{Resultado general del circuito (error previo y actualmente leyendo del sensor)}
    \label{fig:general}
\end{figure}

\section{Conclusiones}

Puede concluirse que el uso de lógica combinacional y secuencial, sensores digitales, registros de desplazamiento y decodificadores permitió capturar, visualizar y verificar correctamente la contraseña, mientras que el BCD a display de siete segmentos facilitó la representación visual del estado del sistema y el motor mostró su aplicación física. 

Además, se concluye que es posible combinar compuertas TTL y CMOS si se realizan las prevenciones y conexiones necesarias, aunque es más laborioso y sería más útil manejar el mismo voltaje en todo. Aún así, el circuito combinatorio implementado con compuertas TTL demuestra la viabilidad de integrar distintos submódulos (como el mux o decoder) de forma funcional e integrarlos con compuertas CMOS (como el registro de desplazamiento) de forma satisfatoria. 

El puente H con transistores 2N222 logró accionar la maqueta del motor, aunque presentó ciertas imperfecciones, por lo que se concluye la necesidad de un diseño más robusto para aplicaciones prácticas más complejas o con mayor corriente.

\section{Recomendaciones}

Basado en la implementación del sistema de puerta con contraseña, es posible realizar varias recomendaciones para implementaciones futuras o para escalar el circuito.

Primeramente, se recomienda optimizar el diseño del puente H. Investigar como tratar con posibles corrientes inesperadas de forma que el circuito sea más robusto (se sugiere diodos de protección por ejemplo).

Considerar el uso de registros de desplazamiento TTL en lugar de CMOS cuando sea posible, para garantizar compatibilidad de niveles lógicos a 5V y reducir la dependencia de buffers adicionales.

Podría implementarse un filtro RC para manejar el filtrado del sensor SW-420 completamente con hardware, para mayor control y aprendizaje.


\section*{Bibliografía}
\bibliographystyle{IEEEtran}
\bibliography{reference} % archivo referencias.bib con formato BibTeX

\end{document}